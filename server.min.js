var Utils = (function () {
    function Utils() {
        // Checks for primitive duplicates in array
        this.arrayIsUnique = function (array) {
            array.sort();
            for (var i = 1; i < array.length; i++) {
                if (array[i - 1] == array[i])
                    return false;
            }
            return true;
        };
        //overwrite Array.prototype.equals to check equality for content
        this.arrayEquals = function (thisArray, otherArray) {
            // if the other array is a falsy value, return
            if (!otherArray)
                return false;
            // compare lengths - can save a lot of time
            if (thisArray.length != otherArray.length)
                return false;
            for (var i = 0, l = thisArray.length; i < l; i++) {
                // Check if we have nested arrays
                if (thisArray[i] instanceof Array && otherArray[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!thisArray[i].equals(otherArray[i]))
                        return false;
                }
                else if (thisArray[i] != otherArray[i]) {
                    // Warning - two different object instances will never be equal: {x:20} != {x:20}
                    return false;
                }
            }
            return true;
        };
    }
    return Utils;
})();
//# sourceMappingURL=utils.js.map
var Config = (function () {
    function Config() {
        this.topics = ['Politics', 'School', 'Fun'];
        this.dhGenerator = 2;
        this.dhPrimeModulo = 4294967295;
        this.privateNumMax = 10;
        this.privateNumMin = 1;
        this.maxMsgLength = 16;
        this.socketToEndpoint = "http://localhost:3000";
        this.socketToEndpoint1 = "http://srmit.azurewebsites.net";
    }
    return Config;
})();
//# sourceMappingURL=config.js.map
var ChatTopic = (function () {
    function ChatTopic(topic) {
        var _this = this;
        this.config = new Config();
        this.topic = '';
        this.clientSockets = [];
        this.clientUISockets = [];
        this.amtOfClients = 0;
        this.clientData = [];
        this.schedule = [];
        this.orderedClientSockets = [];
        this.xorMsgLists = [];
        this.utils = new Utils();
        this.turnCounter = 0;
        this.amtOfClientReadyForNextRound = 0;
        this.ongoingChat = false;
        this.needNewMetadata = false;
        this.activeSockets = [];
        this.subscribeSocketToTopic = function (clientSocket, isBot) {
            _this.addClientSocket(clientSocket, isBot);
        };
        this.sendChatMetadata = function () {
            var bCList = [];
            do {
                _this.schedule = [];
                bCList = [];
                _this.clientData.forEach(function (publicKey) {
                    var privateNumber = Math.floor((Math.random() * _this.config.privateNumMax) + _this.config.privateNumMin);
                    _this.schedule.push(Math.pow(publicKey, privateNumber) % _this.config.dhPrimeModulo);
                    var bC = Math.pow(_this.config.dhGenerator, privateNumber) % _this.config.dhPrimeModulo;
                    bCList.push(bC);
                    //console.log('shedule: ' + this.schedule);
                    if (!_this.utils.arrayIsUnique(_this.schedule)) {
                        console.log('schedule: ' + _this.schedule + ' is not unique so rebuild it');
                    }
                });
            } while (!_this.utils.arrayIsUnique(_this.schedule));
            //console.log('schedule: ' + this.schedule + ' is unique so continue');
            var counter = 0;
            _this.orderedClientSockets.forEach(function (clientSocket) {
                clientSocket.emit('dhAndScheduleData', { dhData: _this.clientData, schedule: _this.schedule, bC: bCList[counter] });
                counter++;
            });
            //console.log('schedule: ' + this.schedule);
        };
        this.addClientData = function (clientSocket, data) {
            _this.orderedClientSockets.push(clientSocket);
            _this.clientData.push(data);
        };
        this.addClientXORmsg = function (xorMsgList) {
            _this.xorMsgLists.push(xorMsgList);
        };
        this.deriveMsg = function () {
            var message = '';
            var currentCharXOR;
            _this.parseXORmsgLists();
            var msgList = _this.getMsgList();
            if (!(msgList.length <= 1)) {
                // remove msgList from xorMsgLists
                for (var i = 0; i < _this.xorMsgLists.length; i++) {
                    if (_this.utils.arrayEquals(_this.xorMsgLists[i], msgList)) {
                        _this.xorMsgLists.splice(i, 1);
                        break;
                    }
                }
                for (var j = 0; j < msgList.length; j++) {
                    currentCharXOR = msgList[j];
                    for (var k = 0; k < _this.xorMsgLists.length; k++) {
                        var temp = currentCharXOR;
                        currentCharXOR = currentCharXOR ^ _this.xorMsgLists[k][0];
                    }
                    message += String.fromCharCode(currentCharXOR);
                }
            }
            else {
                message += '';
            }
            return message;
        };
        this.addClientSocket = function (socket, isBot) {
            var clientExists = false;
            _this.clientSockets.forEach(function (clientSocket) {
                if (clientSocket.id === socket.id) {
                    clientExists = true;
                }
            });
            if (!clientExists) {
                _this.amtOfClients++;
                _this.clientSockets.push(socket);
                if (!isBot) {
                    _this.clientUISockets.push(socket);
                }
            }
        };
        this.removeClientSocket = function (socket) {
            _this.clientUISockets.forEach(function (clientSocket) {
                //console.log('looping through socket: ' + clientSocket.id);
                if (clientSocket.id === socket.id) {
                    var index = _this.clientSockets.indexOf(clientSocket);
                    _this.clientSockets.splice(index, 1);
                    _this.amtOfClients--;
                }
            });
        };
        this.startChat = function () {
            _this.ongoingChat = true;
            _this.turnCounter++;
            _this.clientSockets.forEach(function (clientSocket) {
                clientSocket.emit('startChat');
            });
        };
        this.requestNewMetadata = function () {
            _this.clientData = [];
            _this.orderedClientSockets = [];
            _this.clientSockets.forEach(function (clientSocket) {
                clientSocket.emit('buildClientMetadata');
            });
            _this.ongoingChat = false;
        };
        this.parseXORmsgLists = function () {
            for (var i = 0; i < _this.xorMsgLists.length; i++) {
                var currentList = _this.xorMsgLists[i];
                var zeroIndex = currentList.indexOf(0);
                currentList.splice(zeroIndex);
            }
        };
        this.getMsgList = function () {
            var messageList = [];
            var biggestLength = 0;
            for (var i = 0; i < _this.xorMsgLists.length; i++) {
                if (_this.xorMsgLists[i].length > biggestLength) {
                    biggestLength = _this.xorMsgLists[i].length;
                    messageList = _this.xorMsgLists[i];
                }
            }
            return messageList;
        };
        this.clearRoundData = function () {
            _this.amtOfClientReadyForNextRound = 0;
            _this.xorMsgLists = [];
        };
        this.clearDataForNewMetadata = function () {
            _this.amtOfClientReadyForNextRound = 0;
            _this.xorMsgLists = [];
            _this.setNeedNewMetadata(false);
            _this.schedule = [];
            _this.turnCounter = 0;
        };
        this.incrementAmtOfClientReadyForNextRound = function () {
            _this.amtOfClientReadyForNextRound++;
        };
        this.getTopic = function () {
            return _this.topic;
        };
        this.getClientSockets = function () {
            return _this.clientSockets;
        };
        this.getTurnCounter = function () {
            return _this.turnCounter;
        };
        this.getAmtOfClientReadyForNextRound = function () {
            return _this.amtOfClientReadyForNextRound;
        };
        this.getAmtOfClients = function () {
            return _this.amtOfClients;
        };
        this.getXORmsgListsLength = function () {
            return _this.xorMsgLists.length;
        };
        this.getClientDataLength = function () {
            return _this.clientData.length;
        };
        this.getOngoingChat = function () {
            return _this.ongoingChat;
        };
        this.getNeedNewMetadata = function () {
            return _this.needNewMetadata;
        };
        this.setOngoingChat = function (val) {
            _this.ongoingChat = val;
        };
        this.getScheduleLength = function () {
            return _this.schedule.length;
        };
        this.getActiveSockets = function () {
            return _this.activeSockets;
        };
        this.setNeedNewMetadata = function (val) {
            _this.needNewMetadata = val;
        };
        this.topic = topic;
    }
    return ChatTopic;
})();
//# sourceMappingURL=chatTopic.js.map
var Server = (function () {
    function Server(http) {
        var _this = this;
        this.chatTopicList = [];
        this.utils = new Utils();
        this.config = new Config();
        this.run = function () {
            _this.io.on('connection', function (socket) {
                console.log('client connected (id: ' + socket.id + ')');
                socket.on('ping', function () {
                    socket.emit('pong');
                });
                socket.on('subscribeClientToTopic', function (topic, isBot) {
                    var chatTopic = _this.getChatTopic(topic);
                    socket.chatTopic = topic;
                    _this.removeClientSocket(socket, false);
                    chatTopic.subscribeSocketToTopic(socket, isBot);
                    socket.emit('subscribedToTopic');
                    //this.printClients();
                });
                socket.on('disconnect', function () {
                    //console.log('client disconnected (id: ' + socket.id + ')');             
                    _this.removeClientSocket(socket, true);
                });
                socket.on('clientMetadata', function (metadata) {
                    var chatTopic = _this.getChatTopic(metadata.topic);
                    _this.addClientDataToTopic(socket, metadata.topic, metadata.a);
                    if (chatTopic.getOngoingChat()) {
                        //console.log('--> (WARNING) added client during ongoing chat');                    
                        chatTopic.setNeedNewMetadata(true);
                    }
                    //console.log();
                    //console.log('|Topic: ' + socket.chatTopic + '|');
                    //console.log('chatTopic.getAmtOfClients(): ' + chatTopic.getAmtOfClients());
                    //console.log('chatTopic.getClientDataLength(): ' + chatTopic.getClientDataLength());
                    if (chatTopic.getAmtOfClients() >= 3 && chatTopic.getClientDataLength() == chatTopic.getAmtOfClients()) {
                        chatTopic.startChat();
                    }
                });
                socket.on('xorMsg', function (xorMsg) {
                    _this.addClientXORmsgToTopic(xorMsg.topic, xorMsg.xorMessageList);
                });
                socket.on('readyForNextRound', function (topic) {
                    var chatTopic = _this.getChatTopic(topic);
                    chatTopic.incrementAmtOfClientReadyForNextRound();
                    if (chatTopic.getNeedNewMetadata()) {
                        //console.log('--> (WARNING) new metadata being built');                   
                        chatTopic.clearDataForNewMetadata();
                        chatTopic.requestNewMetadata();
                    }
                    if (chatTopic.getAmtOfClients() == chatTopic.getAmtOfClientReadyForNextRound()) {
                        chatTopic.clearRoundData();
                        chatTopic.startChat();
                    }
                });
            });
        };
        this.broadcastMsgToTopic = function (clientMsg) {
            var chatTopic = _this.getChatTopic(clientMsg.topic);
            chatTopic.getClientSockets().forEach(function (clientSocket) {
                clientSocket.emit('plainTextMsg', { msg: clientMsg.msg, turnCounter: chatTopic.getTurnCounter() });
            });
        };
        this.addClientXORmsgToTopic = function (topic, xorMsgList) {
            var chatTopic = _this.getChatTopic(topic);
            chatTopic.addClientXORmsg(xorMsgList);
            if (chatTopic.getXORmsgListsLength() == chatTopic.getAmtOfClients()) {
                var msg = chatTopic.deriveMsg();
                _this.broadcastMsgToTopic({ topic: topic, msg: msg });
            }
        };
        this.addClientDataToTopic = function (socket, topic, data) {
            var chatTopic = _this.getChatTopic(topic);
            chatTopic.addClientData(socket, data);
            if (!chatTopic.getOngoingChat()) {
                if (chatTopic.getAmtOfClients() >= 3 && chatTopic.getClientDataLength() == chatTopic.getAmtOfClients()) {
                    chatTopic.sendChatMetadata();
                }
            }
        };
        this.removeClientSocket = function (clientSocket, requireNewMetadata) {
            var chatTopic = _this.getChatTopic(clientSocket.chatTopic);
            if (chatTopic != undefined) {
                if (requireNewMetadata) {
                    chatTopic.setNeedNewMetadata(true);
                }
                chatTopic.removeClientSocket(clientSocket);
            }
        };
        this.getChatTopic = function (topic) {
            for (var i = 0; i < _this.chatTopicList.length; i++) {
                if (_this.chatTopicList[i].getTopic() == topic) {
                    return _this.chatTopicList[i];
                }
            }
        };
        this.printClients = function () {
            console.log('\n');
            _this.chatTopicList.forEach(function (chatTopic) {
                console.log('--> clients in topic: ' + chatTopic.getTopic());
                chatTopic.getClientSockets().forEach(function (socket) {
                    console.log(' > id: ' + socket.id);
                });
            });
        };
        this.io = require('socket.io')(http);
        this.config.topics.forEach(function (topic) {
            _this.chatTopicList.push(new ChatTopic(topic));
        });
    }
    return Server;
})();
//# sourceMappingURL=server.js.map
var express = require('express');
var app = express();
var http = require('http').Server(app);
app.use(express.static('public'));
app.get('/', function (req, res) {
    res.sendFile(__dirname + '/Client.html');
});
var port = process.env.port || 3000;
http.listen(port, function () {
    console.log('listening on *:' + port);
    var server = new Server(http);
    server.run();
});
//# sourceMappingURL=app.js.map